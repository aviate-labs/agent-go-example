// Package ledger provides a client for the "ledger" canister.
// Do NOT edit this file. It was automatically generated by https://github.com/aviate-labs/agent-go.
package ledger

import (
	"github.com/aviate-labs/agent-go"
	"github.com/aviate-labs/agent-go/candid/idl"
	"github.com/aviate-labs/agent-go/principal"
)

type Tokens = struct {
	E8s uint64 `ic:"e8s"`
}

type TimeStamp = struct {
	TimestampNanos uint64 `ic:"timestamp_nanos"`
}

type AccountIdentifier = []byte

type SubAccount = []byte

type BlockIndex = uint64

type Transaction = struct {
	Memo          Memo       `ic:"memo"`
	Icrc1Memo     *[]byte    `ic:"icrc1_memo,omitempty"`
	Operation     *Operation `ic:"operation,omitempty"`
	CreatedAtTime TimeStamp  `ic:"created_at_time"`
}

type Memo = uint64

type TransferArgs = struct {
	Memo           Memo              `ic:"memo"`
	Amount         Tokens            `ic:"amount"`
	Fee            Tokens            `ic:"fee"`
	FromSubaccount *SubAccount       `ic:"from_subaccount,omitempty"`
	To             AccountIdentifier `ic:"to"`
	CreatedAtTime  *TimeStamp        `ic:"created_at_time,omitempty"`
}

type TransferError = struct {
	BadFee *struct {
		ExpectedFee Tokens `ic:"expected_fee"`
	} `ic:"BadFee,variant"`
	InsufficientFunds *struct {
		Balance Tokens `ic:"balance"`
	} `ic:"InsufficientFunds,variant"`
	TxTooOld *struct {
		AllowedWindowNanos uint64 `ic:"allowed_window_nanos"`
	} `ic:"TxTooOld,variant"`
	TxCreatedInFuture *struct{} `ic:"TxCreatedInFuture,variant"`
	TxDuplicate       *struct {
		DuplicateOf BlockIndex `ic:"duplicate_of"`
	} `ic:"TxDuplicate,variant"`
}

type TransferResult = struct {
	Ok  *BlockIndex    `ic:"Ok,variant"`
	Err *TransferError `ic:"Err,variant"`
}

type AccountBalanceArgs = struct {
	Account AccountIdentifier `ic:"account"`
}

type TransferFeeArg = struct {
}

type TransferFee = struct {
	TransferFee Tokens `ic:"transfer_fee"`
}

type GetBlocksArgs = struct {
	Start  BlockIndex `ic:"start"`
	Length uint64     `ic:"length"`
}

type Operation = struct {
	Mint *struct {
		To     AccountIdentifier `ic:"to"`
		Amount Tokens            `ic:"amount"`
	} `ic:"Mint,variant"`
	Burn *struct {
		From    AccountIdentifier  `ic:"from"`
		Spender *AccountIdentifier `ic:"spender,omitempty"`
		Amount  Tokens             `ic:"amount"`
	} `ic:"Burn,variant"`
	Transfer *struct {
		From    AccountIdentifier `ic:"from"`
		To      AccountIdentifier `ic:"to"`
		Amount  Tokens            `ic:"amount"`
		Fee     Tokens            `ic:"fee"`
		Spender *[]uint8          `ic:"spender,omitempty"`
	} `ic:"Transfer,variant"`
	Approve *struct {
		From              AccountIdentifier `ic:"from"`
		Spender           AccountIdentifier `ic:"spender"`
		AllowanceE8s      idl.Int           `ic:"allowance_e8s"`
		Allowance         Tokens            `ic:"allowance"`
		Fee               Tokens            `ic:"fee"`
		ExpiresAt         *TimeStamp        `ic:"expires_at,omitempty"`
		ExpectedAllowance *Tokens           `ic:"expected_allowance,omitempty"`
	} `ic:"Approve,variant"`
}

type Block = struct {
	ParentHash  *[]byte     `ic:"parent_hash,omitempty"`
	Transaction Transaction `ic:"transaction"`
	Timestamp   TimeStamp   `ic:"timestamp"`
}

type BlockRange = struct {
	Blocks []Block `ic:"blocks"`
}

type QueryArchiveError = struct {
	BadFirstBlockIndex *struct {
		RequestedIndex  BlockIndex `ic:"requested_index"`
		FirstValidIndex BlockIndex `ic:"first_valid_index"`
	} `ic:"BadFirstBlockIndex,variant"`
	Other *struct {
		ErrorCode    uint64 `ic:"error_code"`
		ErrorMessage string `ic:"error_message"`
	} `ic:"Other,variant"`
}

type QueryArchiveResult = struct {
	Ok  *BlockRange        `ic:"Ok,variant"`
	Err *QueryArchiveError `ic:"Err,variant"`
}

type QueryArchiveFn = struct { /* NOT SUPPORTED */
}

type QueryBlocksResponse = struct {
	ChainLength     uint64                `ic:"chain_length"`
	Certificate     *[]byte               `ic:"certificate,omitempty"`
	Blocks          []Block               `ic:"blocks"`
	FirstBlockIndex BlockIndex            `ic:"first_block_index"`
	ArchivedBlocks  []ArchivedBlocksRange `ic:"archived_blocks"`
}

type ArchivedBlocksRange = struct {
	Start    BlockIndex     `ic:"start"`
	Length   uint64         `ic:"length"`
	Callback QueryArchiveFn `ic:"callback"`
}

type ArchivedEncodedBlocksRange = struct {
	Callback struct { /* NOT SUPPORTED */
	} `ic:"callback"`
	Start  uint64 `ic:"start"`
	Length uint64 `ic:"length"`
}

type QueryEncodedBlocksResponse = struct {
	Certificate     *[]byte                      `ic:"certificate,omitempty"`
	Blocks          [][]byte                     `ic:"blocks"`
	ChainLength     uint64                       `ic:"chain_length"`
	FirstBlockIndex uint64                       `ic:"first_block_index"`
	ArchivedBlocks  []ArchivedEncodedBlocksRange `ic:"archived_blocks"`
}

type Archive = struct {
	CanisterId principal.Principal `ic:"canister_id"`
}

type Archives = struct {
	Archives []Archive `ic:"archives"`
}

type Duration = struct {
	Secs  uint64 `ic:"secs"`
	Nanos uint32 `ic:"nanos"`
}

type ArchiveOptions = struct {
	TriggerThreshold           uint64              `ic:"trigger_threshold"`
	NumBlocksToArchive         uint64              `ic:"num_blocks_to_archive"`
	NodeMaxMemorySizeBytes     *uint64             `ic:"node_max_memory_size_bytes,omitempty"`
	MaxMessageSizeBytes        *uint64             `ic:"max_message_size_bytes,omitempty"`
	ControllerId               principal.Principal `ic:"controller_id"`
	CyclesForArchiveCreation   *uint64             `ic:"cycles_for_archive_creation,omitempty"`
	MaxTransactionsPerResponse *uint64             `ic:"max_transactions_per_response,omitempty"`
}

type TextAccountIdentifier = string

type SendArgs = struct {
	Memo           Memo                  `ic:"memo"`
	Amount         Tokens                `ic:"amount"`
	Fee            Tokens                `ic:"fee"`
	FromSubaccount *SubAccount           `ic:"from_subaccount,omitempty"`
	To             TextAccountIdentifier `ic:"to"`
	CreatedAtTime  *TimeStamp            `ic:"created_at_time,omitempty"`
}

type AccountBalanceArgsDfx = struct {
	Account TextAccountIdentifier `ic:"account"`
}

type FeatureFlags = struct {
	Icrc2 bool `ic:"icrc2"`
}

type InitArgs = struct {
	MintingAccount      TextAccountIdentifier `ic:"minting_account"`
	Icrc1MintingAccount *Account              `ic:"icrc1_minting_account,omitempty"`
	InitialValues       []struct {
		field0 TextAccountIdentifier `ic:"field0"`
		field1 Tokens                `ic:"field1"`
	} `ic:"initial_values"`
	MaxMessageSizeBytes          *uint64               `ic:"max_message_size_bytes,omitempty"`
	TransactionWindow            *Duration             `ic:"transaction_window,omitempty"`
	ArchiveOptions               *ArchiveOptions       `ic:"archive_options,omitempty"`
	SendWhitelist                []principal.Principal `ic:"send_whitelist"`
	TransferFee                  *Tokens               `ic:"transfer_fee,omitempty"`
	TokenSymbol                  *string               `ic:"token_symbol,omitempty"`
	TokenName                    *string               `ic:"token_name,omitempty"`
	FeatureFlags                 *FeatureFlags         `ic:"feature_flags,omitempty"`
	MaximumNumberOfAccounts      *uint64               `ic:"maximum_number_of_accounts,omitempty"`
	AccountsOverflowTrimQuantity *uint64               `ic:"accounts_overflow_trim_quantity,omitempty"`
}

type Icrc1BlockIndex = idl.Nat

type Icrc1Timestamp = uint64

type Icrc1Tokens = idl.Nat

type Account = struct {
	Owner      principal.Principal `ic:"owner"`
	Subaccount *SubAccount         `ic:"subaccount,omitempty"`
}

type TransferArg = struct {
	FromSubaccount *SubAccount     `ic:"from_subaccount,omitempty"`
	To             Account         `ic:"to"`
	Amount         Icrc1Tokens     `ic:"amount"`
	Fee            *Icrc1Tokens    `ic:"fee,omitempty"`
	Memo           *[]byte         `ic:"memo,omitempty"`
	CreatedAtTime  *Icrc1Timestamp `ic:"created_at_time,omitempty"`
}

type Icrc1TransferError = struct {
	BadFee *struct {
		ExpectedFee Icrc1Tokens `ic:"expected_fee"`
	} `ic:"BadFee,variant"`
	BadBurn *struct {
		MinBurnAmount Icrc1Tokens `ic:"min_burn_amount"`
	} `ic:"BadBurn,variant"`
	InsufficientFunds *struct {
		Balance Icrc1Tokens `ic:"balance"`
	} `ic:"InsufficientFunds,variant"`
	TooOld          *struct{} `ic:"TooOld,variant"`
	CreatedInFuture *struct {
		LedgerTime uint64 `ic:"ledger_time"`
	} `ic:"CreatedInFuture,variant"`
	TemporarilyUnavailable *struct{} `ic:"TemporarilyUnavailable,variant"`
	Duplicate              *struct {
		DuplicateOf Icrc1BlockIndex `ic:"duplicate_of"`
	} `ic:"Duplicate,variant"`
	GenericError *struct {
		ErrorCode idl.Nat `ic:"error_code"`
		Message   string  `ic:"message"`
	} `ic:"GenericError,variant"`
}

type Icrc1TransferResult = struct {
	Ok  *Icrc1BlockIndex    `ic:"Ok,variant"`
	Err *Icrc1TransferError `ic:"Err,variant"`
}

type Value = struct {
	Nat  *idl.Nat `ic:"Nat,variant"`
	Int  *idl.Int `ic:"Int,variant"`
	Text *string  `ic:"Text,variant"`
	Blob *[]byte  `ic:"Blob,variant"`
}

type UpgradeArgs = struct {
	MaximumNumberOfAccounts *uint64       `ic:"maximum_number_of_accounts,omitempty"`
	Icrc1MintingAccount     *Account      `ic:"icrc1_minting_account,omitempty"`
	FeatureFlags            *FeatureFlags `ic:"feature_flags,omitempty"`
}

type LedgerCanisterPayload = struct {
	Init    *InitArgs     `ic:"Init,variant"`
	Upgrade **UpgradeArgs `ic:"Upgrade,variant"`
}

type ApproveArgs = struct {
	FromSubaccount    *SubAccount     `ic:"from_subaccount,omitempty"`
	Spender           Account         `ic:"spender"`
	Amount            Icrc1Tokens     `ic:"amount"`
	ExpectedAllowance *Icrc1Tokens    `ic:"expected_allowance,omitempty"`
	ExpiresAt         *Icrc1Timestamp `ic:"expires_at,omitempty"`
	Fee               *Icrc1Tokens    `ic:"fee,omitempty"`
	Memo              *[]byte         `ic:"memo,omitempty"`
	CreatedAtTime     *Icrc1Timestamp `ic:"created_at_time,omitempty"`
}

type ApproveError = struct {
	BadFee *struct {
		ExpectedFee Icrc1Tokens `ic:"expected_fee"`
	} `ic:"BadFee,variant"`
	InsufficientFunds *struct {
		Balance Icrc1Tokens `ic:"balance"`
	} `ic:"InsufficientFunds,variant"`
	AllowanceChanged *struct {
		CurrentAllowance Icrc1Tokens `ic:"current_allowance"`
	} `ic:"AllowanceChanged,variant"`
	Expired *struct {
		LedgerTime uint64 `ic:"ledger_time"`
	} `ic:"Expired,variant"`
	TooOld          *struct{} `ic:"TooOld,variant"`
	CreatedInFuture *struct {
		LedgerTime uint64 `ic:"ledger_time"`
	} `ic:"CreatedInFuture,variant"`
	Duplicate *struct {
		DuplicateOf Icrc1BlockIndex `ic:"duplicate_of"`
	} `ic:"Duplicate,variant"`
	TemporarilyUnavailable *struct{} `ic:"TemporarilyUnavailable,variant"`
	GenericError           *struct {
		ErrorCode idl.Nat `ic:"error_code"`
		Message   string  `ic:"message"`
	} `ic:"GenericError,variant"`
}

type ApproveResult = struct {
	Ok  *Icrc1BlockIndex `ic:"Ok,variant"`
	Err *ApproveError    `ic:"Err,variant"`
}

type AllowanceArgs = struct {
	Account Account `ic:"account"`
	Spender Account `ic:"spender"`
}

type Allowance = struct {
	Allowance Icrc1Tokens     `ic:"allowance"`
	ExpiresAt *Icrc1Timestamp `ic:"expires_at,omitempty"`
}

type TransferFromArgs = struct {
	SpenderSubaccount *SubAccount     `ic:"spender_subaccount,omitempty"`
	From              Account         `ic:"from"`
	To                Account         `ic:"to"`
	Amount            Icrc1Tokens     `ic:"amount"`
	Fee               *Icrc1Tokens    `ic:"fee,omitempty"`
	Memo              *[]byte         `ic:"memo,omitempty"`
	CreatedAtTime     *Icrc1Timestamp `ic:"created_at_time,omitempty"`
}

type TransferFromResult = struct {
	Ok  *Icrc1BlockIndex   `ic:"Ok,variant"`
	Err *TransferFromError `ic:"Err,variant"`
}

type TransferFromError = struct {
	BadFee *struct {
		ExpectedFee Icrc1Tokens `ic:"expected_fee"`
	} `ic:"BadFee,variant"`
	BadBurn *struct {
		MinBurnAmount Icrc1Tokens `ic:"min_burn_amount"`
	} `ic:"BadBurn,variant"`
	InsufficientFunds *struct {
		Balance Icrc1Tokens `ic:"balance"`
	} `ic:"InsufficientFunds,variant"`
	InsufficientAllowance *struct {
		Allowance Icrc1Tokens `ic:"allowance"`
	} `ic:"InsufficientAllowance,variant"`
	TooOld          *struct{} `ic:"TooOld,variant"`
	CreatedInFuture *struct {
		LedgerTime Icrc1Timestamp `ic:"ledger_time"`
	} `ic:"CreatedInFuture,variant"`
	Duplicate *struct {
		DuplicateOf Icrc1BlockIndex `ic:"duplicate_of"`
	} `ic:"Duplicate,variant"`
	TemporarilyUnavailable *struct{} `ic:"TemporarilyUnavailable,variant"`
	GenericError           *struct {
		ErrorCode idl.Nat `ic:"error_code"`
		Message   string  `ic:"message"`
	} `ic:"GenericError,variant"`
}

// Agent is a client for the "ledger" canister.
type Agent struct {
	a          *agent.Agent
	canisterId principal.Principal
}

// NewAgent creates a new agent for the "ledger" canister.
func NewAgent(canisterId principal.Principal, config agent.Config) (*Agent, error) {
	a, err := agent.New(config)
	if err != nil {
		return nil, err
	}
	return &Agent{
		a:          a,
		canisterId: canisterId,
	}, nil
}

// Transfer calls the "transfer" method on the "ledger" canister.
func (a Agent) Transfer(arg0 TransferArgs) (*TransferResult, error) {
	var r0 TransferResult
	if err := a.a.Call(
		a.canisterId,
		"transfer",
		[]any{arg0},
		[]any{&r0},
	); err != nil {
		return nil, err
	}
	return &r0, nil
}

// AccountBalance calls the "account_balance" method on the "ledger" canister.
func (a Agent) AccountBalance(arg0 AccountBalanceArgs) (*Tokens, error) {
	var r0 Tokens
	if err := a.a.Query(
		a.canisterId,
		"account_balance",
		[]any{arg0},
		[]any{&r0},
	); err != nil {
		return nil, err
	}
	return &r0, nil
}

// AccountIdentifier calls the "account_identifier" method on the "ledger" canister.
func (a Agent) AccountIdentifier(arg0 Account) (*AccountIdentifier, error) {
	var r0 AccountIdentifier
	if err := a.a.Query(
		a.canisterId,
		"account_identifier",
		[]any{arg0},
		[]any{&r0},
	); err != nil {
		return nil, err
	}
	return &r0, nil
}

// TransferFee calls the "transfer_fee" method on the "ledger" canister.
func (a Agent) TransferFee(arg0 TransferFeeArg) (*TransferFee, error) {
	var r0 TransferFee
	if err := a.a.Query(
		a.canisterId,
		"transfer_fee",
		[]any{arg0},
		[]any{&r0},
	); err != nil {
		return nil, err
	}
	return &r0, nil
}

// QueryBlocks calls the "query_blocks" method on the "ledger" canister.
func (a Agent) QueryBlocks(arg0 GetBlocksArgs) (*QueryBlocksResponse, error) {
	var r0 QueryBlocksResponse
	if err := a.a.Query(
		a.canisterId,
		"query_blocks",
		[]any{arg0},
		[]any{&r0},
	); err != nil {
		return nil, err
	}
	return &r0, nil
}

// QueryEncodedBlocks calls the "query_encoded_blocks" method on the "ledger" canister.
func (a Agent) QueryEncodedBlocks(arg0 GetBlocksArgs) (*QueryEncodedBlocksResponse, error) {
	var r0 QueryEncodedBlocksResponse
	if err := a.a.Query(
		a.canisterId,
		"query_encoded_blocks",
		[]any{arg0},
		[]any{&r0},
	); err != nil {
		return nil, err
	}
	return &r0, nil
}

// Symbol calls the "symbol" method on the "ledger" canister.
func (a Agent) Symbol() (*struct {
	Symbol string `ic:"symbol"`
}, error) {
	var r0 struct {
		Symbol string `ic:"symbol"`
	}
	if err := a.a.Query(
		a.canisterId,
		"symbol",
		[]any{},
		[]any{&r0},
	); err != nil {
		return nil, err
	}
	return &r0, nil
}

// Name calls the "name" method on the "ledger" canister.
func (a Agent) Name() (*struct {
	Name string `ic:"name"`
}, error) {
	var r0 struct {
		Name string `ic:"name"`
	}
	if err := a.a.Query(
		a.canisterId,
		"name",
		[]any{},
		[]any{&r0},
	); err != nil {
		return nil, err
	}
	return &r0, nil
}

// Decimals calls the "decimals" method on the "ledger" canister.
func (a Agent) Decimals() (*struct {
	Decimals uint32 `ic:"decimals"`
}, error) {
	var r0 struct {
		Decimals uint32 `ic:"decimals"`
	}
	if err := a.a.Query(
		a.canisterId,
		"decimals",
		[]any{},
		[]any{&r0},
	); err != nil {
		return nil, err
	}
	return &r0, nil
}

// Archives calls the "archives" method on the "ledger" canister.
func (a Agent) Archives() (*Archives, error) {
	var r0 Archives
	if err := a.a.Query(
		a.canisterId,
		"archives",
		[]any{},
		[]any{&r0},
	); err != nil {
		return nil, err
	}
	return &r0, nil
}

// SendDfx calls the "send_dfx" method on the "ledger" canister.
func (a Agent) SendDfx(arg0 SendArgs) (*BlockIndex, error) {
	var r0 BlockIndex
	if err := a.a.Call(
		a.canisterId,
		"send_dfx",
		[]any{arg0},
		[]any{&r0},
	); err != nil {
		return nil, err
	}
	return &r0, nil
}

// AccountBalanceDfx calls the "account_balance_dfx" method on the "ledger" canister.
func (a Agent) AccountBalanceDfx(arg0 AccountBalanceArgsDfx) (*Tokens, error) {
	var r0 Tokens
	if err := a.a.Query(
		a.canisterId,
		"account_balance_dfx",
		[]any{arg0},
		[]any{&r0},
	); err != nil {
		return nil, err
	}
	return &r0, nil
}

// Icrc1Name calls the "icrc1_name" method on the "ledger" canister.
func (a Agent) Icrc1Name() (*string, error) {
	var r0 string
	if err := a.a.Query(
		a.canisterId,
		"icrc1_name",
		[]any{},
		[]any{&r0},
	); err != nil {
		return nil, err
	}
	return &r0, nil
}

// Icrc1Symbol calls the "icrc1_symbol" method on the "ledger" canister.
func (a Agent) Icrc1Symbol() (*string, error) {
	var r0 string
	if err := a.a.Query(
		a.canisterId,
		"icrc1_symbol",
		[]any{},
		[]any{&r0},
	); err != nil {
		return nil, err
	}
	return &r0, nil
}

// Icrc1Decimals calls the "icrc1_decimals" method on the "ledger" canister.
func (a Agent) Icrc1Decimals() (*uint8, error) {
	var r0 uint8
	if err := a.a.Query(
		a.canisterId,
		"icrc1_decimals",
		[]any{},
		[]any{&r0},
	); err != nil {
		return nil, err
	}
	return &r0, nil
}

// Icrc1Metadata calls the "icrc1_metadata" method on the "ledger" canister.
func (a Agent) Icrc1Metadata() (*[]struct {
	field0 string `ic:"field0"`
	field1 Value  `ic:"field1"`
}, error) {
	var r0 []struct {
		field0 string `ic:"field0"`
		field1 Value  `ic:"field1"`
	}
	if err := a.a.Query(
		a.canisterId,
		"icrc1_metadata",
		[]any{},
		[]any{&r0},
	); err != nil {
		return nil, err
	}
	return &r0, nil
}

// Icrc1TotalSupply calls the "icrc1_total_supply" method on the "ledger" canister.
func (a Agent) Icrc1TotalSupply() (*Icrc1Tokens, error) {
	var r0 Icrc1Tokens
	if err := a.a.Query(
		a.canisterId,
		"icrc1_total_supply",
		[]any{},
		[]any{&r0},
	); err != nil {
		return nil, err
	}
	return &r0, nil
}

// Icrc1Fee calls the "icrc1_fee" method on the "ledger" canister.
func (a Agent) Icrc1Fee() (*Icrc1Tokens, error) {
	var r0 Icrc1Tokens
	if err := a.a.Query(
		a.canisterId,
		"icrc1_fee",
		[]any{},
		[]any{&r0},
	); err != nil {
		return nil, err
	}
	return &r0, nil
}

// Icrc1MintingAccount calls the "icrc1_minting_account" method on the "ledger" canister.
func (a Agent) Icrc1MintingAccount() (**Account, error) {
	var r0 *Account
	if err := a.a.Query(
		a.canisterId,
		"icrc1_minting_account",
		[]any{},
		[]any{&r0},
	); err != nil {
		return nil, err
	}
	return &r0, nil
}

// Icrc1BalanceOf calls the "icrc1_balance_of" method on the "ledger" canister.
func (a Agent) Icrc1BalanceOf(arg0 Account) (*Icrc1Tokens, error) {
	var r0 Icrc1Tokens
	if err := a.a.Query(
		a.canisterId,
		"icrc1_balance_of",
		[]any{arg0},
		[]any{&r0},
	); err != nil {
		return nil, err
	}
	return &r0, nil
}

// Icrc1Transfer calls the "icrc1_transfer" method on the "ledger" canister.
func (a Agent) Icrc1Transfer(arg0 TransferArg) (*Icrc1TransferResult, error) {
	var r0 Icrc1TransferResult
	if err := a.a.Call(
		a.canisterId,
		"icrc1_transfer",
		[]any{arg0},
		[]any{&r0},
	); err != nil {
		return nil, err
	}
	return &r0, nil
}

// Icrc1SupportedStandards calls the "icrc1_supported_standards" method on the "ledger" canister.
func (a Agent) Icrc1SupportedStandards() (*[]struct {
	Name string `ic:"name"`
	Url  string `ic:"url"`
}, error) {
	var r0 []struct {
		Name string `ic:"name"`
		Url  string `ic:"url"`
	}
	if err := a.a.Query(
		a.canisterId,
		"icrc1_supported_standards",
		[]any{},
		[]any{&r0},
	); err != nil {
		return nil, err
	}
	return &r0, nil
}

// Icrc2Approve calls the "icrc2_approve" method on the "ledger" canister.
func (a Agent) Icrc2Approve(arg0 ApproveArgs) (*ApproveResult, error) {
	var r0 ApproveResult
	if err := a.a.Call(
		a.canisterId,
		"icrc2_approve",
		[]any{arg0},
		[]any{&r0},
	); err != nil {
		return nil, err
	}
	return &r0, nil
}

// Icrc2Allowance calls the "icrc2_allowance" method on the "ledger" canister.
func (a Agent) Icrc2Allowance(arg0 AllowanceArgs) (*Allowance, error) {
	var r0 Allowance
	if err := a.a.Query(
		a.canisterId,
		"icrc2_allowance",
		[]any{arg0},
		[]any{&r0},
	); err != nil {
		return nil, err
	}
	return &r0, nil
}

// Icrc2TransferFrom calls the "icrc2_transfer_from" method on the "ledger" canister.
func (a Agent) Icrc2TransferFrom(arg0 TransferFromArgs) (*TransferFromResult, error) {
	var r0 TransferFromResult
	if err := a.a.Call(
		a.canisterId,
		"icrc2_transfer_from",
		[]any{arg0},
		[]any{&r0},
	); err != nil {
		return nil, err
	}
	return &r0, nil
}
